# Checklist for Testing Components

1. Unit Testing
2. End-to-End Testing
3. Semi-automated Testing
4. Automated GUI Testing

## Unit Testing

Stencil makes it easy to unit test components and app utility functions using Jest. Unit tests validate the code in isolation. Well written tests are fast, repeatable, and easy to reason about.

1. Basic test without properties (must)
2. Test property mapping (optional)
3. Test conditions (optional)
4. Test loops (optional)
5. Test public functions (must)

### 1. Basic test without properties (default)

Test that the initial component gets rendered correctly without any values.

```javascript
import { newSpecPage } from '@stencil/core/testing';

describe('example', () => {
  it('initial', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component>
        <mock:shadow-root>
          <span class="component">
            <slot></slot>
          </span>
        </mock:shadow-root>
      </my-component>
    ');
  });
});
```

### 2. Test property mapping

Test the result after setting all input values out of default values.

```javascript
import { newSpecPage } from '@stencil/core/testing';

describe('example', () => {
  it('mapped properties', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp variant="secondary"></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component variant="secondary">
        <mock:shadow-root>
          <span class="component" data-variant="secondary">
            <slot></slot>
          </span>
        </mock:shadow-root>
      </my-component>
    ');
  });
});
```

### 3. Test conditions (this.value > 1, 'if' and 'switch/case')

Test two results generated by condition for true and false side

```javascript
import { newSpecPage } from '@stencil/core/testing';

describe('example', () => {
  it('condition false', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp value=0></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component value=0>
        <mock:shadow-root>
          <span class="class-for-lower-value">
            <slot></slot>
          </span>
        </mock:shadow-root>
      </my-component>
    ');
  });

  it('condition true', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp value=2></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component value=2>
        <mock:shadow-root>
          <span class="class-for-higher-value">
            <slot></slot>
          </span>
        </mock:shadow-root>
      </my-component>
    ');
  });
});
```

### 4. Test loops (value = ["item1", "item2", "item3"])

Test three results generated by loop, one with empty loop, one with one single item and one with filled loop

```javascript
import { newSpecPage } from '@stencil/core/testing';

describe('example', () => {
  it('loop is empty', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp items=[]></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component>
        <mock:shadow-root>
          <div class="list-wrapper"><div>
        </mock:shadow-root>
      </my-component>
    ');
  });

   it('loop with one single item', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp value=["item1"]></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component value=["item1", "item2", "item3"]>
        <mock:shadow-root>
          <div class="list-wrapper">
            <ul>
                <li>item 1</li>
            </ul>
          <div>
        </mock:shadow-root>
      </my-component>
    ');
  });

   it('loop is filled', async () => {
    const page = await newSpecPage({
      components: [MyComponent],
      html: '<my-comp value=["item1", "item2", "item3"]></my-comp>',
    });

    expect(page.root).toEqualHtml('
      <my-component value=["item1", "item2", "item3"]>
        <mock:shadow-root>
          <div class="list-wrapper">
            <ul>
                <li>item 1</li>
                <li>item 2</li>
                <li>item 3</li>
            </ul>
          <div>
        </mock:shadow-root>
      </my-component>
    ');
  });
});
```

### 5. Test public API (must, readme.md)

Test same way like component depending on input value an business logic.

```javascript
import { newSpecPage } from '@stencil/core/testing';
import { MyComponent } from from '../my-component';

describe('example', () => {
  it('builds', () => {
    expect(new MyComponent()).toBeTruthy();
  });

  describe('test edge cases of function', () => {
    it('without values', () => {
      const component = new MyComponent();
      expect(component.testFunction()).toEqual('');
    });

    it('with emtpy value, () => {
      const component = new MyComponent();
      component.value = '';
      expect(component.testFunction()).toEqual('');
    });

    it('with value', () => {
      const component = new MyComponent();
      component.value = 'test';
      expect(component.testFunction()).toEqual('test');
    });
  });
});
```

## End-to-End Tests (integration tests, detecing changes on runtime)

E2E tests verify your components in a real browser. For example, when my-component has the X attribute, the child component then renders the text Y, and expects to receive the event Z. By using Puppeteer for rendering tests (rather than a Node environment simulating how a browser works), your end-to-end tests are able to run within an actual browser in order to give better results.

1. Basic test without properties (optional)
2. Property change (must)
3. Text content change (must when business logic)
4. Test after event was fired (must)

5. Tests für lifecycle hooks?

### 1. Basic test without properties

Test that the initial component gets rendered correctly without any values.

```javascript
import { newE2EPage } from "@stencil/core/testing";

describe("example", () => {
  it("should render a my-comp", async () => {
    const page = await newE2EPage();
    await page.setContent("<my-comp></my-comp>");
    const el = await page.find("my-comp");

    expect(el).not.toBeNull();
  });
});
```

### 2. Property change

Test that a property changes on runtime.

```javascript
import { newE2EPage } from "@stencil/core/testing";

describe("example", () => {
  it("should render a my-comp", async () => {
    // init page
    const page = await newE2EPage();
    await page.setContent('<my-comp></my-comp>');
    
    // init component
    const component = await page.find("my-comp");
    let value = await slider.getProperty("value");

    expect(value).toBe(30);
    // perform actions that should change the value
    expect(await component.getProperty("value")).toBe(31);
  });

  it('test output binding', async () => {
    const page = await newE2EPage();
    await page.setContent('<my-comp></my-comp>');

    const component = await page.find('my-comp');
    let value = component.getAttribute('value')

    expect(value).toBe('primary');

    // perform action that should change the value and reinit
    component.setProperty('value', 'secondary');
    await page.waitForChanges();
    value = component.getAttribute('value');

    expect(value).toBe('secondary');
  });

  it('test input binding', async () => {
    const page = await newE2EPage();
    await page.setContent('<my-comp></my-comp>');

    const component = await page.find('my-comp');
    let value = await component.getProperty('value');
    
    expect(value).toBe('primary');

    // perform action that should change the value and reinit
    component.setAttribute('value', 'secondary');
    await page.waitForChanges();
    value = await component.getProperty('value');

    expect(value).toBe('secondary');
  });
});
```

### 3. Text content change

Test that a property changes on runtime. (example: input 'hello world' --> 'good morning - hello world') @TODO: discuss when to use it

```javascript
import { newE2EPage } from "@stencil/core/testing";

describe("example", () => {
  it("should render a my-comp", async () => {
    const button = await page.find("my-comp >>> button");
    const  text = button.textContent;

    expect(text).toBe("good morning - hello world");
  });
});
```

### 4. Test after event was fired

Test that a attribute changes after event was fired.

```javascript
import { newE2EPage } from "@stencil/core/testing";

describe("example", () => {
  it("should render a my-comp", async () => {
    const component = await page.find("my-comp");
    const input = await page.find("my-comp >>> input");

    await input.press("8");

    expect(component).toHaveAttribute("attribute");
    expect(component).toEqualAttribute("attribute", "value");
  });
});
```

## Semi-automated tests

- Accessebiltiy Tests mit AI Inspector

## Automated GUI Testing

- Selenium (Sequenztests)
- Screenshot Tests (fragwürdig)
